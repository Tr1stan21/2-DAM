package dao.impl;

import connection.DatabaseConnection;
import dao.GenericDao;
import model.Student;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class AlumnoDaoImpl implements GenericDao<Student, Integer> {
    private static final String INSERT_SQL =
            "INSERT INTO alumno (nombre, email, fecha_alta) VALUES (?, ?, ?)";

    private static final String SELECT_BY_ID_SQL =
            "SELECT id_alumno, nombre, email, fecha_alta FROM alumno WHERE id_alumno = ?";

    private static final String SELECT_ALL_SQL =
            "SELECT id_alumno, nombre, email, fecha_alta FROM alumno";

    private static final String UPDATE_SQL =
            "UPDATE alumno SET nombre = ?, email = ?, fecha_alta = ? WHERE id_alumno = ?";

    private static final String DELETE_SQL =
            "DELETE FROM alumno WHERE id_alumno = ?";

    /**
     * Inserts a new Student into the database and assigns the generated ID.
     *
     * @param student student to be created
     * @return the same student with its generated ID populated
     */
    @Override
    public Student create(Student student) {
        try (Connection c = DatabaseConnection.getConnection();
             PreparedStatement ps = c.prepareStatement(INSERT_SQL, Statement.RETURN_GENERATED_KEYS)) {

            ps.setString(1, student.getName());
            ps.setString(2, student.getEmail());
            ps.setDate(3, Date.valueOf(student.getCreatedAt()));

            ps.executeUpdate();

            // Retrieve primary key generated by the database
            try (ResultSet rs = ps.getGeneratedKeys()) {
                if (rs.next()) {
                    student.setId(rs.getInt(1));
                }
            }

        } catch (SQLException e) {
            throw new RuntimeException("Error inserting student", e);
        }

        return student;
    }

    /**
     * Fetches a Student by its ID.
     *
     * @param id student's identifier
     * @return the student if found, otherwise null
     */
    @Override
    public Student findById(Integer id) {
        try (Connection c = DatabaseConnection.getConnection();
             PreparedStatement ps = c.prepareStatement(SELECT_BY_ID_SQL)) {

            ps.setInt(1, id);

            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next()) {
                    return mapRowToStudent(rs);
                }
            }

        } catch (SQLException e) {
            throw new RuntimeException("Error fetching student by id", e);
        }

        return null;
    }

    /**
     * Returns all students stored in the database.
     *
     * @return a list containing all students
     */
    @Override
    public List<Student> findAll() {
        List<Student> students = new ArrayList<>();

        try (Connection c = DatabaseConnection.getConnection();
             PreparedStatement ps = c.prepareStatement(SELECT_ALL_SQL);
             ResultSet rs = ps.executeQuery()) {

            while (rs.next()) {
                students.add(mapRowToStudent(rs));
            }

        } catch (SQLException e) {
            throw new RuntimeException("Error fetching all students", e);
        }

        return students;
    }

    /**
     * Updates an existing student.
     *
     * @param student student containing updated data
     * @return the updated student
     */
    @Override
    public Student update(Student student) {
        if (student.getId() == null) {
            throw new IllegalArgumentException("Student id must not be null for update");
        }

        try (Connection c = DatabaseConnection.getConnection();
             PreparedStatement ps = c.prepareStatement(UPDATE_SQL)) {

            ps.setString(1, student.getName());
            ps.setString(2, student.getEmail());
            ps.setDate(3, Date.valueOf(student.getCreatedAt()));
            ps.setInt(4, student.getId());

            ps.executeUpdate();

        } catch (SQLException e) {
            throw new RuntimeException("Error updating student", e);
        }

        return student;
    }

    /**
     * Deletes a student by its ID.
     *
     * @param id identifier of the student to delete
     */
    @Override
    public void deleteById(Integer id) {
        try (Connection c = DatabaseConnection.getConnection();
             PreparedStatement ps = c.prepareStatement(DELETE_SQL)) {

            ps.setInt(1, id);
            ps.executeUpdate();

        } catch (SQLException e) {
            throw new RuntimeException("Error deleting student by id", e);
        }
    }

    /**
     * Maps a ResultSet row to a Student entity.
     *
     * @param rs result set pointing to a row
     * @return a Student object populated with database values
     */
    private Student mapRowToStudent(ResultSet rs) throws SQLException {
        Student student = new Student();

        student.setId(rs.getInt("id_alumno"));
        student.setName(rs.getString("nombre"));
        student.setEmail(rs.getString("email"));

        Date d = rs.getDate("fecha_alta");
        if (d != null) {
            student.setCreatedAt(d.toLocalDate());
        }

        return student;
    }

    //BATCH
    /**
     * Inserts multiple students into the 'alumno' table using batch processing.
     * Each batch is executed and committed.
     *
     * @param students  array of Student objects to insert
     * @param batchSize number of students per batch
     */
    public void insertStudentsByBatches(Student[] students, int batchSize) {
        if (students == null || students.length == 0) {
            return;
        }
        if (batchSize <= 0) {
            throw new IllegalArgumentException("batchSize must be greater than 0");
        }


        try (Connection c = DatabaseConnection.getConnection();
             PreparedStatement ps = c.prepareStatement(INSERT_SQL)) {

            c.setAutoCommit(false);

            int pos = insertFullBatches(students, batchSize, ps, c);
            insertRemainingStudents(students, pos, ps, c);

            c.setAutoCommit(true);

        } catch (SQLException e) {
            throw new RuntimeException("Error during batch student insertion", e);
        }
    }

    /**
     * Inserts all full batches of size batchSize.
     * Returns the index where remaining students start.
     */
    private int insertFullBatches(Student[] students, int batchSize, PreparedStatement ps, Connection c) throws SQLException {
        int fullBatches = students.length / batchSize;

        for (int batchIndex = 0; batchIndex < fullBatches; batchIndex++) {
            int from = batchIndex * batchSize;
            int to = from + batchSize;

            addStudentsToBatch(students, from, to, ps);
            executeAndCommitBatch(ps, c);
        }

        return fullBatches * batchSize;
    }

    /**
     * Inserts the remaining students that don't form a full batch.
     */
    private void insertRemainingStudents(Student[] students, int startIndex, PreparedStatement ps, Connection c) throws SQLException {
        if (startIndex >= students.length) {
            return;
        }

        addStudentsToBatch(students, startIndex, students.length, ps);
        executeAndCommitBatch(ps, c);
    }

    /**
     * Adds students to the current batch from index 'from' (inclusive)
     * to index 'to' (exclusive).
     */
    private void addStudentsToBatch(Student[] students, int from, int to, PreparedStatement ps) throws SQLException {
        for (int i = from; i < to; i++) {
            Student st = students[i];

            ps.setString(1, st.getName());
            ps.setString(2, st.getEmail());
            ps.setDate(3, Date.valueOf(st.getCreatedAt()));

            ps.addBatch();
        }
    }

    /**
     * Executes the current batch, checks for execution errors,
     * and commits the transaction.
     * If any element fails, the transaction is rolled back
     * and a SQLException is thrown.
     */
    private void executeAndCommitBatch(PreparedStatement ps, Connection c) throws SQLException {
        int[] results = ps.executeBatch();

        for (int r : results) {
            if (r == Statement.EXECUTE_FAILED) {
                c.rollback();
                throw new SQLException("Batch execution failed");
            }
        }

        ps.clearBatch();
        c.commit();
    }

}
